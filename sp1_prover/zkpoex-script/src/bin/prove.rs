//! An end-to-end example of using the SP1 SDK to generate a proof of a program that can be verified
//! on-chain.
//!
//! You can run this script using the following command:
//! ```shell
//! RUST_LOG=info cargo run --package fibonacci-script --bin prove --release
//! ```

use std::path::PathBuf;

use alloy_sol_types::{sol, SolType};
use clap::Parser;
use rand::Rng;
use serde::{Deserialize, Serialize};
use sp1_sdk::{HashableKey, ProverClient, SP1Stdin};

/// The ELF (executable and linkable format) file for the Succinct RISC-V zkVM.
///
/// This file is generated by running `cargo prove build` inside the `program` directory.
pub const ZKPOEX_ELF: &[u8] = include_bytes!("../../../zk-poex/elf/riscv32im-succinct-zkvm-elf");

/// The arguments for the prove command.
#[derive(Parser, Debug)]
#[clap(author, version, about, long_about = None)]
struct ProveArgs {
    #[clap(long)]
    calldata: String,
    #[clap(
        long,
        default_value = r#"
    {
        "gas_price": "0",
        "origin": "0x0000000000000000000000000000000000000000",
        "block_hashes": "[]",
        "block_number": "0",
        "block_coinbase": "0x0000000000000000000000000000000000000000",
        "block_timestamp": "0",
        "block_difficulty": "0",
        "block_gas_limit": "0",
        "chain_id": "1",
        "block_base_fee_per_gas": "0"
    }
"#
    )]
    blockchain_settings: String,
}

/// A fixture that can be used to test the verification of SP1 zkVM proofs inside Solidity.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
struct SP1ZkPoExProofFixture {
    key: [u8; 32],
    nonce: [u8; 12],
    calldata: String,
    blockchain_settings: String,
    vkey: String,
}

fn main() {
    // Setup the logger.
    sp1_sdk::utils::setup_logger();

    // Parse the command line arguments.
    let args = ProveArgs::parse();

    let mut rng = rand::thread_rng();

    let key: [u8; 32] = rng.gen();
    let nonce: [u8; 12] = rng.gen();

    // Setup the prover client.
    let client = ProverClient::new();

    // Setup the program.
    let (pk, vk) = client.setup(ZKPOEX_ELF);

    // Setup the inputs.;
    let mut stdin = SP1Stdin::new();
    stdin.write(&(
        key,
        nonce,
        args.calldata.clone(),
        args.blockchain_settings.clone(),
    ));

    // Generate the proof.
    let proof = client
        .prove_compressed(&pk, stdin)
        .expect("failed to generate proof");

    std::fs::write(
        PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("./zkpoex_enc_key"),
        key,
    )
    .expect("failed to write fixture");

    // Create the testing fixture so we can test things end-ot-end.
    let fixture = SP1ZkPoExProofFixture {
        key,
        nonce,
        calldata: args.calldata,
        blockchain_settings: args.blockchain_settings,
        vkey: vk.bytes32().to_string(),
    };

    let _ = proof.save("./zkpoex.bincode");

    // The verification key is used to verify that the proof corresponds to the execution of the
    // program on the given input.
    //
    // Note that the verification key stays the same regardless of the input.
    println!("Verification Key: {}", fixture.vkey);

    // The public values are the values whicha are publically commited to by the zkVM.
    //
    // If you need to expose the inputs or outputs of your program, you should commit them in
    // the public values.
    println!("Public Values: {}", proof.public_values.bytes());

    // Save the fixture to a file.
    let fixture_path = PathBuf::from(env!("CARGO_MANIFEST_DIR")).join("../contracts/src/fixtures");
    std::fs::create_dir_all(&fixture_path).expect("failed to create fixture path");
    std::fs::write(
        fixture_path.join("zkpoex_fixture.json"),
        serde_json::to_string_pretty(&fixture).unwrap(),
    )
    .expect("failed to write fixture");
}
